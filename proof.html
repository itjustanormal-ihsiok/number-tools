<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<title>數字論證系統（完整版）</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#0b1220;--card:#0f1724;--muted:#9aa4b2;--accent:#06f}
  body{font-family:Inter,ui-sans-serif,system-ui; background:var(--bg); color:#e6eef6; margin:0;padding:24px}
  .card{background:var(--card); padding:18px;border-radius:10px;box-shadow:0 6px 30px rgba(2,6,23,.6)}
  h1{margin:0 0 12px 0;font-size:20px}
  label{display:block;margin:8px 0;color:var(--muted)}
  input{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,.06);background:transparent;color:inherit}
  button{padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#012;cursor:pointer}
  #result{white-space:pre-wrap;background:#071028;padding:12px;border-radius:8px;margin-top:12px;color:#dfe7f3;min-height:120px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .small{font-size:13px;color:var(--muted)}
  .steps{margin-top:8px;color:#bcd;white-space:pre-wrap;display:none}
  a.eglink{color:#7fffd4;text-decoration:none}
</style>
</head>
<body>
<div class="card">
  <h1>數字論證系統（高級版）
    <sup style="font-size:12px; color:#999;">對了，說到高級</sup>
  </h1>
  <div class="small">惡臭數字請至專門網站論證</div>

  <label>被論證數（target）</label>
  <input id="target" value="" />
  <label>論證數（proof）</label>
  <input id="proof" value="" />

  <div style="margin-top:10px" class="row">
    <button id="run" type="button">執行</button>
    <button id="ex1" type="button">範例：12345 ← 54321</button>
    <button id="clear" type="button">清除</button>
  </div>

  <div id="result">執行後結果會顯示在這裡。</div>
  <div class="steps" id="steps" style="display:none"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const $ = id => document.getElementById(id);

  // ---------- 工具 ----------
  function trimTrailingZerosDecimal(s){
    if(!s.includes('.')) return s;
    s = s.replace(/\.0+$/,'');
    s = s.replace(/(\.[0-9]*?)0+$/,'$1');
    if(s.endsWith('.')) s = s.slice(0,-1);
    return s;
  }
  function isAllZeroString(s){ return /^-?0+(?:\.0+)?$/.test(s); }

  function makeBuilder(baseDigits){
    let pos = 0; const L = baseDigits.length;
    return {
      peek(n){ let res=''; for(let i=0;i<n;i++) res+=baseDigits[(pos+i)%L]; return {str:res,val:parseInt(res,10),len:n}; },
      consume(n){ pos=(pos+n)%L; },
      getRemainCycle(){ const r=pos%L; let remain=''; for(let i=r;i<L;i++) remain+=baseDigits[i]; return remain; },
      reset(){ pos=0; }
    };
  }

  const TEN_0FACT = '((0!+0!)(0!+0!+0!+0!+0!))';
  function pow0Product(k){ if(k===0) return '0!'; return Array(k).fill('(0!+0!)').join(''); }
  function wrapParen(s){ return `(${s})`; }

  function scrambleString(s){
    const arr = s.split('');
    for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
    return arr.join('');
  }
  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // 將輸入字串淨化成只保留正負、小數與數字（用於檢查特殊數字）
  function normalizeForCheck(s){
    if(typeof s !== 'string') s = String(s||'');
    return s.replace(/[^0-9\-\.]/g,'');
  }
  function containsDigitsSequence(s, seq){
    const clean = normalizeForCheck(s).replace(/^[-+]/,'');
    // 為了匹配小數或負號情況，先移除小數點與前導符號再檢查子字串
    const digitsOnly = clean.replace(/\./g,'');
    return digitsOnly.indexOf(String(seq)) !== -1;
  }

  // 0! 表示法（把 value 用 2 的二進位分解）
  function zeroProofRepresentation(value, decimalShift, negative){
    if(value===0){
      let out = '0!';
      if(decimalShift>0){ for(let i=0;i<decimalShift;i++){ out = wrapParen(out) + ' ÷ ' + TEN_0FACT; } }
      if(negative) out = wrapParen(out) + ' *(-0!)';
      return out;
    }
    const parts = []; let v=value>>>0, k=0;
    while(v>0){ if(v & 1) parts.push(k); v >>= 1; k++; }
    parts.reverse();
    const exprParts = parts.map(exp => exp===0 ? '0!' : pow0Product(exp));
    let expr = exprParts.join(' + ');
    if(decimalShift>0){ for(let i=0;i<decimalShift;i++){ expr = wrapParen(expr) + ' ÷ ' + TEN_0FACT; } }
    if(negative) expr = wrapParen(expr) + ' *(-0!)';
    return expr;
  }

  // ---------- 主程式 ----------
  function proveNumber(rawTarget, rawProof){
    // 保留原始輸入字串（方便彩蛋使用）
    const origT = rawTarget === undefined ? '' : String(rawTarget);
    const origP = rawProof === undefined ? '' : String(rawProof);

    // 淨化與基本檢查
    let tRaw = trimTrailingZerosDecimal(String(rawTarget||''));
    let pRaw = trimTrailingZerosDecimal(String(rawProof||''));
    if(tRaw === '') tRaw = '0';
    if(pRaw === '') pRaw = '0';
    if(!isFinite(Number(tRaw)) || !isFinite(Number(pRaw))) return { text: '輸入非數字', html:false, color:null };

    // 用來檢查特殊數字的淨化字串
    const tCleanDigits = normalizeForCheck(tRaw).replace(/^[-+]/,'').replace(/\./g,'');
    const pCleanDigits = normalizeForCheck(pRaw).replace(/^[-+]/,'').replace(/\./g,'');
    const tNum = Number(tRaw);
    const pNum = Number(pRaw);

    // ---------- 超級彩蛋（優先） ----------
    // 33550336 -> 重新載入（user 想要真的重整）
    if(tCleanDigits.indexOf('33550336') !== -1 || pCleanDigits.indexOf('33550336') !== -1){
      // 顯示提示，再短暫延遲後重整，避免直接在函式裡終止
      setTimeout(()=> location.reload(), 150);
      return { text: '', html:false, color:null };
    }

    // 111410208 與 350234 同時出現（不論 target/proof 哪側）
    const has111 = (tCleanDigits.indexOf('111410208') !== -1) || (pCleanDigits.indexOf('111410208') !== -1);
    const has350234 = (tCleanDigits.indexOf('350234') !== -1) || (pCleanDigits.indexOf('350234') !== -1);
    if(has111 && has350234){
      return { text: '帶著你的苦命鴛鴦吃大份去吧！', html:false, color:null };
    }

    // 111410208 作 target，且 proof 為 114514 或 1919810 （即使有小數或負號）
    if(tCleanDigits.indexOf('111410208') !== -1 && (pCleanDigits.indexOf('114514') !== -1 || pCleanDigits.indexOf('1919810') !== -1)){
      return { text: '兄啊，你為啥拿這麼臭的東西論證我啊（悲', html:false, color:null };
    }
    // 111410208 作 proof，且 target 為 114514 或 1919810
    if(pCleanDigits.indexOf('111410208') !== -1 && (tCleanDigits.indexOf('114514') !== -1 || tCleanDigits.indexOf('1919810') !== -1)){
      return { text: '兄啊，你拿我論證什麼東西啊（惱', html:false, color:null };
    }

    // 單獨 114514 或 1919810（任一端出現，優於 target=0）
    if(tCleanDigits.indexOf('114514') !== -1 || pCleanDigits.indexOf('114514') !== -1 ||
       tCleanDigits.indexOf('1919810') !== -1 || pCleanDigits.indexOf('1919810') !== -1){
      return { text: '這麼臭的數字有論證的必要嗎？（大悲', html:false, color:null };
    }

    // ---------- 進入 target=0 / proof=0 與 一般演算（但不要覆蓋最終彩蛋） ----------
    let finalExpr = '';
    // target == 0 處理（但不要阻止後續最終式的彩蛋）
    if(isAllZeroString(tRaw)){
      if(isAllZeroString(pRaw)){
        finalExpr = '0 = 0';
      } else {
        // 0 = proof - proof
        finalExpr = `${origT} = ${origP} - ${origP}`;
      }
    }
    // proof == 0 使用 0! 分支（如果上面 target=0 則已處理）
    if(finalExpr === '' && isAllZeroString(pRaw)){
      // 把 target 放大為整數（若有小數）
      let tProc = tRaw;
      let negative = false;
      if(tProc.startsWith('-')){ negative = true; tProc = tProc.slice(1); }
      let decimalShift = 0;
      if(tProc.includes('.')) { decimalShift = tProc.split('.')[1].length; tProc = tProc.replace('.',''); }
      const val = parseInt(tProc,10) || 0;
      const expr = zeroProofRepresentation(val, decimalShift, negative);
      finalExpr = `${origT} = ${expr}`;
    }

    // 一般 builder 演算（當 finalExpr 尚未被設置）
    if(finalExpr === ''){
      // 我們實作你之前要求的 builder 算法（拆 proof 為循環數字）
      const baseDigits = pCleanDigits.split('');
      if(baseDigits.length === 0) return { text: 'invalid proof', html:false, color:null };

      const builder = makeBuilder(baseDigits);
      let targetIntStr = tRaw;
      // 若 target 有小數則先放大（但這裡已於上方排除小數為 proof==0 分支）
      // 為簡潔，我們把 tRaw（經 trim）直接轉成整數表示（如果是帶小數且 proof != 0，之前已不會是 finalExpr），
      // 但要支援小數的完整放大與除回展示：先找小數位數
      let decimalShift = 0;
      let negTarget = false;
      if(tRaw.startsWith('-')){ negTarget = true; tRaw = tRaw.slice(1); }
      if(tRaw.includes('.')){ decimalShift = tRaw.split('.')[1].length; tRaw = tRaw.replace('.',''); }
      let targetVal = parseInt(tRaw,10) || 0; if(negTarget) targetVal = -targetVal;

      const exprParts = [];
      let outerGuard = 0;
      while(Math.abs(targetVal) >= 10 && outerGuard < 2000000){
        outerGuard++;
        let n = 1;
        let prev = null;
        while(true){
          const candidateObj = builder.peek(n);
          const candidate = candidateObj.val;
          const testRemain = (targetVal >= 0) ? (targetVal - candidate) : (targetVal + candidate);
          const crossed = (targetVal >= 0) ? (testRemain < 0) : (testRemain > 0);

          if(crossed){
            if(prev !== null){
              if(Math.abs(testRemain) < Math.abs(prev.remain)){
                exprParts.push(`${candidateObj.str}${targetVal>=0?'-':'+'}`);
                targetVal = testRemain; builder.consume(candidateObj.len);
              } else {
                exprParts.push(`${prev.obj.str}${targetVal>=0?'+':'-'}`);
                targetVal = prev.remain; builder.consume(prev.obj.len);
              }
            } else {
              exprParts.push(`${candidateObj.str}${targetVal>=0?'-':'+'}`);
              targetVal = testRemain; builder.consume(candidateObj.len);
            }
            break;
          }
          prev = { obj: candidateObj, remain: testRemain };
          n++;
          if(testRemain === 0){
            exprParts.push(`${candidateObj.str}${targetVal>=0?'-':'+'}`);
            builder.consume(candidateObj.len);
            targetVal = 0;
            break;
          }
          // safety: avoid insane n
          if(n > 1000){
            exprParts.push('/* inner-limit */');
            break;
          }
        }
      }

      // 尾端收尾（未完成個位循環消除 + ±1 修正）
      // 尾端收尾（修正：就算 targetVal == 0 也強制補結構，避免尾巴殘符）
      const remCycle = builder.getRemainCycle();

      // 無論是否為 0，都補上 (剩餘循環)(proof-proof)
      if(remCycle && remCycle.length > 0){
        exprParts.push(`${remCycle}*(${pRaw} - ${pRaw})`);
      }

      // 把剩餘按單位 proof/proof 加減直到歸零
      if(Math.abs(targetVal) > 0){
        const remAbs = Math.abs(targetVal);
        if(remAbs <= 1000){
         while(targetVal !== 0){
           if(targetVal > 0){ exprParts.push(`+ ${pRaw}/${pRaw}`); targetVal -= 1; }
           else { exprParts.push(`- ${pRaw}/${pRaw}`); targetVal += 1; }
         }
       } else {
         exprParts.push(`+ ${pRaw}/${pRaw} * ${remAbs}`);
       }
      }


      if(negTarget && exprParts.length > 0){
        exprParts[0] = '-' + exprParts[0];
      }

      // 組合 finalExpr；若最初 target 有小數（decimalShift>0），把 finalExpr 用括號包起來並補 ÷ 表示（使用 proof/proof 結構）
      let built = exprParts.length ? exprParts.join(' ') : '0';
      if(decimalShift > 0){
        // 以 (proof/proof) 的 (2*5) 結構來表示除以 10（如你要的）
        const inner2 = '(' + Array(2).fill(`${pRaw}/${pRaw}`).join('+') + ')';
        const inner5 = '(' + Array(5).fill(inner2).join('+') + ')';
        for(let i=0;i<decimalShift;i++){
          built = wrapParen(built) + ' ÷ ' + inner5;
        }
      }
      finalExpr = `${origT} = ${built}`;
    }

    // ---------- 最終彩蛋（對 finalExpr 進行後處理） ----------
    let outStr = finalExpr;
    let useHtml = false;
    let color = null;

    // 0721 -> 末尾加表情，並轉為有超連結（由 displayResult 負責產生 anchor）
    if(containsDigitsSequence(origT, '0721') || containsDigitsSequence(origP, '0721')){
      useHtml = true;
      outStr = outStr + ' (∠・ω＜)⌒☆';
    }

    // 24601 -> 灰色
    if(containsDigitsSequence(origT, '24601') || containsDigitsSequence(origP, '24601')){
      color = '#777';
    }

    // 228922 -> scramble 最終式子（作用在最終結果）
    if(containsDigitsSequence(origT, '228922') || containsDigitsSequence(origP, '228922')){
      outStr = scrambleString(outStr);
    }

    // proof == 9 -> 把所有 9 用 ⑨ 替換（但排除某些特殊 target）
    const specialTargets = ['1919810','114514','350234','228922','111410208'];
    const tDigitsOnly = tCleanDigits;
    let skip9 = specialTargets.some(s => tDigitsOnly.indexOf(s) !== -1);
    if(pNum === 9 && !skip9){
      outStr = outStr.replace(/9/g,'⑨');
    }

    // proof == 39 -> 文字顏色改青（但排除特殊 target）
    let skip39 = specialTargets.some(s => tDigitsOnly.indexOf(s) !== -1);
    if(pNum === 39 && !skip39){
      color = '#0ff';
    }

    // 350234 單獨在這裡：輸出 "t和p真是一對苦命鴛鴦啊"（顯示數字）
    if(containsDigitsSequence(origT, '350234') || containsDigitsSequence(origP, '350234')){
      // 以原始輸入（保留小數/負號）或轉為 Number 顯示更自然
      const tShow = (origT||'').toString();
      const pShow = (origP||'').toString();
      outStr = `${tShow}和${pShow}真是一對苦命鴛鴦啊`;
      // 不使用 HTML / 顏色影響（除非其它彩蛋也要求）
      // 若同時出現 0721 等，在上方已處理（此處覆寫文字）
    }

    return { text: outStr, html: useHtml, color: color };
  }

  // ---------- 顯示與 UI 綁定 ----------
  function displayResult(obj){
    const resEl = $('result'); if(!resEl) return;
    resEl.style.color = obj.color || '';
    if(obj.html){
      const href = 'https://reurl.cc/xKDZR1';
      // 文字用 escapeHtml 避 XSS
      resEl.innerHTML = `<a class="eglink" href="${href}" target="_blank" rel="noopener">${escapeHtml(obj.text)}</a>`;
    } else {
      resEl.textContent = obj.text;
    }
  }

  function run(){
    const t = $('target').value;
    const p = $('proof').value;
    const resEl = $('result'); if(resEl) resEl.textContent = '';
    try{
      const out = proveNumber(t,p);
      displayResult(out);
    } catch(e){
      const resEl2 = $('result'); if(resEl2) resEl2.textContent = '錯誤：' + (e && e.message ? e.message : String(e));
      console.error(e);
    }
  }

  $('run').onclick = run;
  $('ex1').onclick = ()=>{ $('target').value='12345'; $('proof').value='54321'; run(); };
  $('clear').onclick = ()=>{ const resEl=$('result'); if(resEl) resEl.textContent=''; };

  // quick console tests (uncomment for debugging)
  // console.log('tests:', proveNumber('123456','6354'));
  // console.log('tests:', proveNumber('4445','2147'));
  // console.log('tests:', proveNumber('1919810','114514'));
  // console.log('tests:', proveNumber('0.25','0'));
  // console.log('tests:', proveNumber('-439','0'));
});
</script>
</body>
</html>
